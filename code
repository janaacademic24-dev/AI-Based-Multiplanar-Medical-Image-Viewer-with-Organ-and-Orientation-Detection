"""
Enhanced DICOM Viewer with AI Orientation Detection & Advanced Features
Features:
- AI organ detection with CLIP/ResNet50
- True oblique plane slicing (not rotation)
- ROI selection and export
- Batch slice export
- Zoom and pan functionality
- Improved UI layout
"""

import sys
import numpy as np
from pathlib import Path
import pydicom
from scipy import ndimage
from PIL import Image
import cv2

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLabel, QSlider, QFileDialog, QMessageBox,
    QGroupBox, QComboBox, QDoubleSpinBox, QSpinBox, QDialog,
    QDialogButtonBox, QCheckBox, QScrollArea, QSplitter
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QRect, QPoint
from PyQt5.QtGui import QPixmap, QImage, QPainter, QPen, QColor, QCursor, QWheelEvent

try:
    import torch
    import torchvision.models as models
    from torchvision import transforms
    TORCH_AVAILABLE = True
except ImportError:
    TORCH_AVAILABLE = False
    print("WARNING: PyTorch not installed. Run: pip install torch torchvision")

try:
    import importlib
    import os
    open_clip = importlib.import_module('open_clip')
    os.environ['HF_HUB_DISABLE_SYMLINKS_WARNING'] = '1'
    CLIP_AVAILABLE = True
except Exception:
    CLIP_AVAILABLE = False
    open_clip = None
    print("WARNING: open_clip not installed. Run: pip install open_clip_torch")

ORGAN_LABELS = ["Brain", "Chest", "Abdomen", "Pelvis", "Spine", "Extremity"]


def plane_from_dicom_tags(ds):
    """Determine imaging plane from DICOM ImageOrientationPatient tag"""
    iop = getattr(ds, 'ImageOrientationPatient', None)
    if iop is None or len(iop) < 6:
        return "Unknown"
    
    try:
        row = np.array(iop[:3], dtype=float)
        col = np.array(iop[3:6], dtype=float)
        normal = np.cross(row, col)
        axis = int(np.argmax(np.abs(normal)))
        
        plane_map = {0: "Sagittal", 1: "Coronal", 2: "Axial"}
        return plane_map.get(axis, "Unknown")
    except:
        return "Unknown"


def extract_oblique_slice(volume, angle_degrees, slice_position):
    """
    Extract an oblique slice from volume at given angle.
    angle_degrees: rotation angle in XY plane
    slice_position: normalized position (0-1) along the rotated direction
    """
    angle_rad = np.deg2rad(angle_degrees)
    
    # Volume dimensions
    depth, height, width = volume.shape
    
    # Calculate the direction vector for the oblique plane
    direction = np.array([np.cos(angle_rad), np.sin(angle_rad), 0])
    
    # Calculate the center of the volume
    center = np.array([depth / 2, height / 2, width / 2])
    
    # Calculate the maximum distance along the direction
    max_dist = np.sqrt((depth * np.cos(angle_rad))**2 + (height * np.sin(angle_rad))**2)
    
    # Calculate the starting point based on slice_position
    start_pos = slice_position * max_dist - max_dist / 2
    slice_center = center + direction * start_pos
    
    # Create the oblique slice
    oblique_slice = np.zeros((width, int(max_dist)), dtype=volume.dtype)
    
    for i in range(int(max_dist)):
        for j in range(width):
            # Calculate the 3D position
            x = slice_center[0] + direction[0] * (i - max_dist / 2)
            y = slice_center[1] + direction[1] * (i - max_dist / 2)
            z = j
            
            # Check bounds and interpolate
            if 0 <= x < depth - 1 and 0 <= y < height - 1 and 0 <= z < width:
                x0, y0 = int(x), int(y)
                x1, y1 = min(x0 + 1, depth - 1), min(y0 + 1, height - 1)
                
                # Bilinear interpolation
                dx, dy = x - x0, y - y0
                
                v00 = volume[x0, y0, int(z)]
                v01 = volume[x0, y1, int(z)]
                v10 = volume[x1, y0, int(z)]
                v11 = volume[x1, y1, int(z)]
                
                value = (v00 * (1 - dx) * (1 - dy) +
                        v01 * (1 - dx) * dy +
                        v10 * dx * (1 - dy) +
                        v11 * dx * dy)
                
                oblique_slice[j, i] = value
    
    return oblique_slice


class AIThread(QThread):
    """Background thread for AI inference"""
    finished = pyqtSignal(dict)
    progress = pyqtSignal(str)
    
    def __init__(self, volume, spacing=(1.0, 1.0, 1.0), orientation=None):
        super().__init__()
        self.volume = volume.copy()
        self.spacing = spacing
        self.orientation = orientation
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    
    def run(self):
        try:
            if not TORCH_AVAILABLE:
                self.progress.emit("ERROR: PyTorch not installed")
                self.finished.emit({'error': 'PyTorch not installed'})
                return
            
            if CLIP_AVAILABLE:
                self.progress.emit("Loading CLIP (ViT-B/32)...")
                self.clip_model, _, self.clip_preprocess = open_clip.create_model_and_transforms(
                    'ViT-B-32', pretrained='laion2b_s34b_b79k', device=self.device
                )
                self.clip_model.eval()
                self.clip_tokenizer = open_clip.get_tokenizer('ViT-B-32')
                use_clip = True
            else:
                self.progress.emit("Loading ResNet50...")
                self.model = models.resnet50(weights=models.ResNet50_Weights.DEFAULT)
                self.model = self.model.to(self.device)
                self.model.eval()
                self.preprocess = transforms.Compose([
                    transforms.ToTensor(),
                    transforms.Resize((224, 224)),
                    transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                       std=[0.229, 0.224, 0.225])
                ])
                use_clip = False
            
            self.progress.emit("Analyzing slices...")
            
            axial_idx = self.volume.shape[2] // 2
            coronal_idx = self.volume.shape[1] // 2
            sagittal_idx = self.volume.shape[0] // 2
            
            axial_slice = self.volume[:, :, axial_idx]
            coronal_slice = self.volume[:, coronal_idx, :]
            sagittal_slice = self.volume[sagittal_idx, :, :]
            
            if use_clip:
                pred_axial = self.predict_slice_clip(axial_slice, "Axial")
                pred_coronal = self.predict_slice_clip(coronal_slice, "Coronal")
                pred_sagittal = self.predict_slice_clip(sagittal_slice, "Sagittal")
            else:
                pred_axial = self.predict_slice_resnet(axial_slice, "Axial")
                pred_coronal = self.predict_slice_resnet(coronal_slice, "Coronal")
                pred_sagittal = self.predict_slice_resnet(sagittal_slice, "Sagittal")
            
            slice_predictions = [pred_axial, pred_coronal, pred_sagittal]
            
            self.progress.emit(f"Axial: {pred_axial['class']} ({pred_axial['confidence']*100:.1f}%)")
            self.progress.emit(f"Coronal: {pred_coronal['class']} ({pred_coronal['confidence']*100:.1f}%)")
            self.progress.emit(f"Sagittal: {pred_sagittal['class']} ({pred_sagittal['confidence']*100:.1f}%)")
            
            segmentation = self.generate_segmentation()
            volume_stats = self.calculate_statistics()
            
            self.progress.emit("Analysis complete!")
            
            result = {
                'segmentation': segmentation,
                'slice_predictions': slice_predictions,
                'volume_stats': volume_stats,
                'orientation': self.orientation if self.orientation else 'Unknown',
                'device': str(self.device),
                'model_used': 'CLIP (ViT-B/32)' if use_clip else 'ResNet50'
            }
            
            self.finished.emit(result)
            
        except Exception as e:
            self.progress.emit(f"Error: {str(e)}")
            self.finished.emit({'error': str(e)})
    
    def _normalize_slice(self, slice_data):
        if slice_data.max() > slice_data.min():
            normalized = (slice_data - slice_data.min()) / (slice_data.max() - slice_data.min())
            return (normalized * 255).astype(np.uint8)
        return np.zeros_like(slice_data, dtype=np.uint8)
    
    def _to_rgb(self, slice_data):
        normalized = self._normalize_slice(slice_data)
        return np.stack([normalized] * 3, axis=-1)
    
    def predict_slice_clip(self, slice_data, view_name):
        try:
            rgb_slice = self._to_rgb(slice_data)
            pil_img = Image.fromarray(rgb_slice)
            image = self.clip_preprocess(pil_img).unsqueeze(0).to(self.device)
            prompts = [f"a medical CT scan showing {label}" for label in ORGAN_LABELS]
            
            with torch.no_grad():
                text = self.clip_tokenizer(prompts).to(self.device)
                image_features = self.clip_model.encode_image(image)
                text_features = self.clip_model.encode_text(text)
                
                image_features = image_features / image_features.norm(dim=-1, keepdim=True)
                text_features = text_features / text_features.norm(dim=-1, keepdim=True)
                
                logits = (image_features @ text_features.t()) * 100
                probs = logits.softmax(dim=-1).squeeze(0)
                confidence, predicted = torch.max(probs, 0)
            
            return {
                'view': view_name,
                'class': ORGAN_LABELS[int(predicted.item())],
                'confidence': float(confidence.item()),
                'class_id': int(predicted.item())
            }
        except Exception as e:
            return {'view': view_name, 'class': 'Error', 'confidence': 0.0, 'class_id': -1}
    
    def predict_slice_resnet(self, slice_data, view_name):
        try:
            rgb_slice = self._to_rgb(slice_data)
            img_tensor = self.preprocess(rgb_slice).unsqueeze(0).to(self.device)
            
            with torch.no_grad():
                output = self.model(img_tensor)
                probabilities = torch.nn.functional.softmax(output, dim=1)
                confidence, predicted = torch.max(probabilities, 1)
            
            class_map = {0: "Brain", 1: "Chest", 2: "Abdomen", 3: "Pelvis", 4: "Spine", 5: "Extremity"}
            pred_idx = int(predicted.item()) % len(class_map)
            
            return {
                'view': view_name,
                'class': class_map[pred_idx],
                'confidence': float(confidence.item()),
                'class_id': pred_idx
            }
        except Exception as e:
            return {'view': view_name, 'class': 'Error', 'confidence': 0.0, 'class_id': -1}
    
    def generate_segmentation(self):
        segmentation = np.zeros_like(self.volume, dtype=np.uint16)
        normalized = (self.volume - self.volume.min()) / (self.volume.max() - self.volume.min() + 1e-8)
        
        segmentation[normalized > 0.7] = 5
        segmentation[(normalized > 0.5) & (normalized <= 0.7)] = 3
        segmentation[(normalized > 0.3) & (normalized <= 0.5)] = 1
        
        return segmentation
    
    def calculate_statistics(self):
        voxel_volume = np.prod(self.spacing)
        return {
            'Total_Volume_ml': float(self.volume.size * voxel_volume / 1000.0),
            'Mean_Intensity': float(np.mean(self.volume)),
            'Std_Intensity': float(np.std(self.volume)),
            'Min_Intensity': float(np.min(self.volume)),
            'Max_Intensity': float(np.max(self.volume)),
        }


class DicomLoader:
    @staticmethod
    def load_dicom_folder(folder_path):
        folder = Path(folder_path)
        dicom_files = sorted(list(folder.glob("*.dcm")) + list(folder.glob("*.DCM")))
        
        if not dicom_files:
            raise ValueError("No DICOM files found in folder")
        
        slices = []
        for idx, f in enumerate(dicom_files):
            try:
                ds = pydicom.dcmread(str(f), force=True)
                pos = float(getattr(ds, 'InstanceNumber', idx))
                slices.append((pos, ds))
            except Exception as e:
                print(f"Warning: Could not read {f}: {e}")
                continue
        
        if not slices:
            raise ValueError("No valid DICOM slices found")
        
        slices.sort(key=lambda x: x[0])
        
        first_ds = slices[0][1]
        rows, cols = first_ds.pixel_array.shape
        volume = np.zeros((rows, cols, len(slices)), dtype=np.float32)
        
        for i, (pos, ds) in enumerate(slices):
            arr = ds.pixel_array.astype(np.float32)
            
            if hasattr(ds, 'RescaleSlope') and hasattr(ds, 'RescaleIntercept'):
                arr = arr * float(ds.RescaleSlope) + float(ds.RescaleIntercept)
            
            volume[:, :, i] = arr
        
        spacing = [1.0, 1.0, 1.0]
        if hasattr(first_ds, 'PixelSpacing'):
            spacing[0] = float(first_ds.PixelSpacing[0])
            spacing[1] = float(first_ds.PixelSpacing[1])
        if hasattr(first_ds, 'SliceThickness'):
            spacing[2] = float(first_ds.SliceThickness)
        
        orientation = plane_from_dicom_tags(first_ds)
        
        return volume, volume.shape, np.min(volume), np.max(volume), tuple(spacing), orientation


class BatchExportDialog(QDialog):
    """Dialog for batch exporting slices"""
    def __init__(self, max_slices, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Batch Export Slices")
        self.setModal(True)
        
        layout = QVBoxLayout(self)
        
        # View selection
        layout.addWidget(QLabel("Select View:"))
        self.view_combo = QComboBox()
        self.view_combo.addItems(["Axial", "Coronal", "Sagittal"])
        layout.addWidget(self.view_combo)
        
        # Range selection
        range_layout = QHBoxLayout()
        range_layout.addWidget(QLabel("Start Slice:"))
        self.start_spin = QSpinBox()
        self.start_spin.setRange(0, max_slices - 1)
        self.start_spin.setValue(0)
        range_layout.addWidget(self.start_spin)
        
        range_layout.addWidget(QLabel("End Slice:"))
        self.end_spin = QSpinBox()
        self.end_spin.setRange(0, max_slices - 1)
        self.end_spin.setValue(max_slices - 1)
        range_layout.addWidget(self.end_spin)
        layout.addLayout(range_layout)
        
        # Step selection
        step_layout = QHBoxLayout()
        step_layout.addWidget(QLabel("Step (every N slices):"))
        self.step_spin = QSpinBox()
        self.step_spin.setRange(1, 50)
        self.step_spin.setValue(1)
        step_layout.addWidget(self.step_spin)
        layout.addLayout(step_layout)
        
        # Buttons
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
    
    def get_parameters(self):
        return {
            'view': self.view_combo.currentText(),
            'start': self.start_spin.value(),
            'end': self.end_spin.value(),
            'step': self.step_spin.value()
        }


class InteractiveImageViewer(QLabel):
    """Enhanced image viewer with zoom, pan, and ROI selection"""
    
    def __init__(self, view_name):
        super().__init__()
        self.view_name = view_name
        self.setMinimumSize(400, 400)
        self.setAlignment(Qt.AlignCenter)
        self.setScaledContents(False)
        self.setStyleSheet("border: 2px solid #555; background: #1a1a1a;")
        
        # Zoom and pan
        self.zoom_factor = 1.0
        self.pan_offset = QPoint(0, 0)
        self.is_panning = False
        self.last_pan_point = QPoint()
        
        # ROI selection
        self.roi_mode = False
        self.roi_start = None
        self.roi_rect = None
        self.drawing_roi = False
        
        # Image data
        self.current_array = None
        self.base_pixmap = None
        self.ref_lines = {'h': None, 'v': None}
        
        self.setMouseTracking(True)
        self.setCursor(Qt.CrossCursor)
    
    def set_roi_mode(self, enabled):
        self.roi_mode = enabled
        if enabled:
            self.setCursor(Qt.CrossCursor)
        else:
            self.setCursor(Qt.ArrowCursor)
            self.roi_rect = None
    
    def display_array(self, arr, show_ref=False):
        if arr is None or arr.size == 0:
            return
        
        self.current_array = arr.copy()
        arr = np.ascontiguousarray(arr.astype(np.uint8))
        h, w = arr.shape
        
        qimg = QImage(arr.data, w, h, w, QImage.Format_Grayscale8)
        self.base_pixmap = QPixmap.fromImage(qimg.copy())
        
        self.update_display(show_ref)
    
    def update_display(self, show_ref=False):
        if self.base_pixmap is None:
            return
        
        pixmap = self.base_pixmap.copy()
        painter = QPainter(pixmap)
        
        # Draw reference lines
        if show_ref and (self.ref_lines['h'] is not None or self.ref_lines['v'] is not None):
            painter.setPen(QPen(QColor(0, 255, 255), 2))
            
            if self.ref_lines['h'] is not None:
                y = int(self.ref_lines['h'] * pixmap.height())
                painter.drawLine(0, y, pixmap.width(), y)
            
            if self.ref_lines['v'] is not None:
                x = int(self.ref_lines['v'] * pixmap.width())
                painter.drawLine(x, 0, x, pixmap.height())
        
        # Draw ROI rectangle
        if self.roi_rect is not None:
            painter.setPen(QPen(QColor(255, 0, 0), 2))
            painter.drawRect(self.roi_rect)
        
        painter.end()
        
        # Apply zoom
        if self.zoom_factor != 1.0:
            new_size = pixmap.size() * self.zoom_factor
            pixmap = pixmap.scaled(new_size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
        else:
            # Scale to fit the widget size while maintaining aspect ratio
            pixmap = pixmap.scaled(self.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        
        self.setPixmap(pixmap)
    
    def set_reference_lines(self, h_pos=None, v_pos=None):
        self.ref_lines['h'] = h_pos
        self.ref_lines['v'] = v_pos
    
    def wheelEvent(self, event: QWheelEvent):
        # Zoom with mouse wheel
        delta = event.angleDelta().y()
        if delta > 0:
            self.zoom_factor = min(self.zoom_factor * 1.1, 5.0)
        else:
            self.zoom_factor = max(self.zoom_factor * 0.9, 0.5)
        
        self.update_display(True)
    
    def resizeEvent(self, event):
        """Handle widget resize to scale image"""
        super().resizeEvent(event)
        if self.base_pixmap is not None:
            self.update_display(True)
    
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            if self.roi_mode:
                self.roi_start = event.pos()
                self.drawing_roi = True
            else:
                self.is_panning = True
                self.last_pan_point = event.pos()
                self.setCursor(Qt.ClosedHandCursor)
    
    def mouseMoveEvent(self, event):
        if self.drawing_roi and self.roi_start is not None:
            # Update ROI rectangle
            current_pos = event.pos()
            x = min(self.roi_start.x(), current_pos.x())
            y = min(self.roi_start.y(), current_pos.y())
            w = abs(current_pos.x() - self.roi_start.x())
            h = abs(current_pos.y() - self.roi_start.y())
            self.roi_rect = QRect(x, y, w, h)
            self.update_display(True)
    
    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            if self.drawing_roi:
                self.drawing_roi = False
            if self.is_panning:
                self.is_panning = False
                self.setCursor(Qt.ArrowCursor if not self.roi_mode else Qt.CrossCursor)
    
    def get_roi_array(self):
        """Extract the selected ROI from the current array"""
        if self.roi_rect is None or self.current_array is None:
            return None
        
        # Convert screen coordinates to image coordinates
        if self.base_pixmap is None:
            return None
        
        scale_x = self.current_array.shape[1] / self.base_pixmap.width()
        scale_y = self.current_array.shape[0] / self.base_pixmap.height()
        
        x = int(self.roi_rect.x() * scale_x)
        y = int(self.roi_rect.y() * scale_y)
        w = int(self.roi_rect.width() * scale_x)
        h = int(self.roi_rect.height() * scale_y)
        
        # Ensure bounds
        x = max(0, min(x, self.current_array.shape[1] - 1))
        y = max(0, min(y, self.current_array.shape[0] - 1))
        w = min(w, self.current_array.shape[1] - x)
        h = min(h, self.current_array.shape[0] - y)
        
        return self.current_array[y:y+h, x:x+w]
    
    def reset_zoom(self):
        self.zoom_factor = 1.0
        self.pan_offset = QPoint(0, 0)
        self.update_display(True)


class DicomViewerGUI(QMainWindow):
    """Enhanced DICOM Viewer with improved layout"""
    
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Advanced DICOM Viewer - AI Orientation & Organ Detection")
        self.setGeometry(50, 50, 1800, 1000)
        
        self.volume = None
        self.dims = None
        self.min_val = None
        self.max_val = None
        self.spacing = None
        self.orientation = None
        
        self.axial_idx = 0
        self.coronal_idx = 0
        self.sagittal_idx = 0
        self.fourth_idx = 0
        
        self.setup_ui()
    
    def setup_ui(self):
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Top toolbar
        toolbar = self.create_toolbar()
        main_layout.addLayout(toolbar)
        
        # Main viewing area with grid layout
        views_widget = QWidget()
        views_layout = QVBoxLayout(views_widget)
        views_layout.setSpacing(5)
        
        # Top row: Axial and Coronal
        top_row = QHBoxLayout()
        top_row.addLayout(self.create_view_panel("Axial", 'axial'))
        top_row.addLayout(self.create_view_panel("Coronal", 'coronal'))
        views_layout.addLayout(top_row, 1)
        
        # Bottom row: Sagittal and Fourth view
        bottom_row = QHBoxLayout()
        bottom_row.addLayout(self.create_view_panel("Sagittal", 'sagittal'))
        bottom_row.addLayout(self.create_fourth_view_panel())
        views_layout.addLayout(bottom_row, 1)
        
        main_layout.addWidget(views_widget, 1)
        
        # Status bar
        self.status_label = QLabel("Ready | Load DICOM to begin")
        self.status_label.setStyleSheet(
            "background: #2c3e50; color: white; padding: 10px; "
            "font-size: 14px; border-radius: 5px;"
        )
        main_layout.addWidget(self.status_label)
    
    def create_toolbar(self):
        """Create top toolbar with all controls"""
        toolbar = QHBoxLayout()
        
        # File operations
        file_group = QGroupBox("File Operations")
        file_layout = QHBoxLayout(file_group)
        
        load_btn = QPushButton("üìÅ Load DICOM")
        load_btn.clicked.connect(self.load_dicom)
        load_btn.setStyleSheet("padding: 10px; font-size: 13px; font-weight: bold;")
        file_layout.addWidget(load_btn)
        
        export_batch_btn = QPushButton("üíæ Batch Export")
        export_batch_btn.clicked.connect(self.batch_export_slices)
        export_batch_btn.setStyleSheet("padding: 10px; font-size: 13px;")
        self.export_batch_btn = export_batch_btn
        self.export_batch_btn.setEnabled(False)
        file_layout.addWidget(export_batch_btn)
        
        toolbar.addWidget(file_group)
        
        # AI Analysis
        ai_group = QGroupBox("AI Analysis")
        ai_layout = QHBoxLayout(ai_group)
        
        self.analyze_btn = QPushButton("ü§ñ Run AI Analysis")
        self.analyze_btn.clicked.connect(self.run_analysis)
        self.analyze_btn.setEnabled(False)
        self.analyze_btn.setStyleSheet(
            "background: #27ae60; color: white; padding: 10px; "
            "font-size: 13px; font-weight: bold;"
        )
        ai_layout.addWidget(self.analyze_btn)
        
        toolbar.addWidget(ai_group)
        
        # ROI Tools
        roi_group = QGroupBox("ROI Tools")
        roi_layout = QHBoxLayout(roi_group)
        
        self.roi_toggle = QPushButton("‚úè Draw ROI")
        self.roi_toggle.setCheckable(True)
        self.roi_toggle.clicked.connect(self.toggle_roi_mode)
        self.roi_toggle.setStyleSheet("padding: 10px; font-size: 13px;")
        roi_layout.addWidget(self.roi_toggle)
        
        save_roi_btn = QPushButton("üíæ Save ROI")
        save_roi_btn.clicked.connect(self.save_roi)
        save_roi_btn.setStyleSheet("padding: 10px; font-size: 13px;")
        roi_layout.addWidget(save_roi_btn)
        
        toolbar.addWidget(roi_group)
        
        # View controls
        view_group = QGroupBox("View Controls")
        view_layout = QHBoxLayout(view_group)
        
        reset_zoom_btn = QPushButton("üîç Reset Zoom")
        reset_zoom_btn.clicked.connect(self.reset_all_zoom)
        reset_zoom_btn.setStyleSheet("padding: 10px; font-size: 13px;")
        view_layout.addWidget(reset_zoom_btn)
        
        toolbar.addWidget(view_group)
        
        # Info display
        self.info_label = QLabel("No data loaded")
        self.info_label.setStyleSheet(
            "font-size: 12px; padding: 10px; background: #34495e; "
            "color: white; border-radius: 5px;"
        )
        toolbar.addWidget(self.info_label, 1)
        
        return toolbar
    
    def create_view_panel(self, title, view_name):
        """Create a complete view panel with title, image, and controls"""
        panel_layout = QVBoxLayout()
        panel_layout.setSpacing(5)
        
        # Title with background
        title_label = QLabel(title)
        title_label.setStyleSheet(
            "font-weight: bold; font-size: 16px; background: #34495e; "
            "color: white; padding: 8px; border-radius: 5px;"
        )
        title_label.setAlignment(Qt.AlignCenter)
        panel_layout.addWidget(title_label)
        
        # Image viewer
        image = InteractiveImageViewer(view_name)
        setattr(self, f"{view_name}_image", image)
        panel_layout.addWidget(image, 1)
        
        # Controls row
        controls_layout = QHBoxLayout()
        
        # Slider
        slider = QSlider(Qt.Horizontal)
        slider.setEnabled(False)
        slider.valueChanged.connect(lambda v: self.update_view(view_name, v))
        slider.setStyleSheet("QSlider::groove:horizontal { height: 8px; }")
        setattr(self, f"{view_name}_slider", slider)
        controls_layout.addWidget(slider, 1)
        
        # Slice label
        slice_label = QLabel("0/0")
        slice_label.setStyleSheet("font-size: 12px; min-width: 60px;")
        slice_label.setAlignment(Qt.AlignCenter)
        setattr(self, f"{view_name}_slice_label", slice_label)
        controls_layout.addWidget(slice_label)
        
        panel_layout.addLayout(controls_layout)
        
        return panel_layout
    
    def create_fourth_view_panel(self):
        """Create fourth view with oblique plane controls"""
        panel_layout = QVBoxLayout()
        panel_layout.setSpacing(5)
        
        # Title
        title_label = QLabel("Oblique / MIP View")
        title_label.setStyleSheet(
            "font-weight: bold; font-size: 16px; background: #8e44ad; "
            "color: white; padding: 8px; border-radius: 5px;"
        )
        title_label.setAlignment(Qt.AlignCenter)
        panel_layout.addWidget(title_label)
        
        # Mode selector
        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Mode:"))
        self.fourth_mode = QComboBox()
        self.fourth_mode.addItems(["Oblique Plane", "MIP (Maximum Intensity)"])
        self.fourth_mode.currentTextChanged.connect(self.update_fourth_mode)
        self.fourth_mode.setStyleSheet("font-size: 12px; padding: 5px;")
        mode_layout.addWidget(self.fourth_mode, 1)
        panel_layout.addLayout(mode_layout)
        
        # Angle control (for oblique)
        angle_layout = QHBoxLayout()
        angle_layout.addWidget(QLabel("Angle:"))
        self.oblique_angle = QDoubleSpinBox()
        self.oblique_angle.setRange(0, 180)
        self.oblique_angle.setValue(0)
        self.oblique_angle.setSuffix("¬∞")
        self.oblique_angle.setSingleStep(5)
        self.oblique_angle.valueChanged.connect(self.update_oblique_parameters)
        self.oblique_angle.setStyleSheet("font-size: 12px; padding: 5px;")
        angle_layout.addWidget(self.oblique_angle, 1)
        panel_layout.addLayout(angle_layout)
        
        # Image viewer
        self.fourth_image = InteractiveImageViewer('fourth')
        panel_layout.addWidget(self.fourth_image, 1)
        
        # Controls
        controls_layout = QHBoxLayout()
        
        self.fourth_slider = QSlider(Qt.Horizontal)
        self.fourth_slider.setEnabled(False)
        self.fourth_slider.valueChanged.connect(lambda v: self.update_view('fourth', v))
        self.fourth_slider.setStyleSheet("QSlider::groove:horizontal { height: 8px; }")
        controls_layout.addWidget(self.fourth_slider, 1)
        
        self.fourth_slice_label = QLabel("0/0")
        self.fourth_slice_label.setStyleSheet("font-size: 12px; min-width: 60px;")
        self.fourth_slice_label.setAlignment(Qt.AlignCenter)
        controls_layout.addWidget(self.fourth_slice_label)
        
        panel_layout.addLayout(controls_layout)
        
        return panel_layout
    
    def load_dicom(self):
        """Load DICOM folder"""
        folder = QFileDialog.getExistingDirectory(self, "Select DICOM Folder")
        if not folder:
            return
        
        try:
            self.status_label.setText("‚è≥ Loading DICOM files...")
            QApplication.processEvents()
            
            loader = DicomLoader()
            self.volume, self.dims, self.min_val, self.max_val, self.spacing, self.orientation = \
                loader.load_dicom_folder(folder)
            
            # Set initial indices
            self.axial_idx = self.dims[2] // 2
            self.coronal_idx = self.dims[1] // 2
            self.sagittal_idx = self.dims[0] // 2
            self.fourth_idx = 0
            
            # Configure axial slider
            self.axial_slider.setMaximum(self.dims[2] - 1)
            self.axial_slider.setValue(self.axial_idx)
            self.axial_slider.setEnabled(True)
            
            # Configure coronal slider
            self.coronal_slider.setMaximum(self.dims[1] - 1)
            self.coronal_slider.setValue(self.coronal_idx)
            self.coronal_slider.setEnabled(True)
            
            # Configure sagittal slider
            self.sagittal_slider.setMaximum(self.dims[0] - 1)
            self.sagittal_slider.setValue(self.sagittal_idx)
            self.sagittal_slider.setEnabled(True)
            
            # Configure fourth view slider
            self.update_oblique_parameters()
            
            # Update info
            self.info_label.setText(
                f"Volume: {self.dims[0]}√ó{self.dims[1]}√ó{self.dims[2]} | "
                f"Orientation: {self.orientation} | "
                f"Spacing: {self.spacing[0]:.2f}√ó{self.spacing[1]:.2f}√ó{self.spacing[2]:.2f} mm"
            )
            
            self.update_all_views()
            self.analyze_btn.setEnabled(True)
            self.export_batch_btn.setEnabled(True)
            self.status_label.setText(f"‚úÖ Loaded successfully | Detected: {self.orientation} orientation")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to load DICOM:\n{str(e)}")
            self.status_label.setText("‚ùå Error loading DICOM")
    
    def update_oblique_parameters(self):
        """Update oblique slider range based on angle"""
        if self.volume is None:
            return
        
        angle = self.oblique_angle.value()
        
        # Calculate number of slices available at this angle
        depth, height, width = self.volume.shape
        angle_rad = np.deg2rad(angle)
        max_dist = int(np.sqrt((depth * np.cos(angle_rad))**2 + (height * np.sin(angle_rad))**2))
        
        # Update slider
        self.fourth_slider.setMaximum(max(1, max_dist - 1))
        self.fourth_slider.setValue(max_dist // 2)
        self.fourth_slider.setEnabled(True)
        
        self.update_view('fourth', self.fourth_slider.value())
    
    def update_view(self, view_name, idx):
        """Update specific view"""
        if self.volume is None:
            return
        
        if view_name == 'axial':
            self.axial_idx = idx
            self.axial_slice_label.setText(f"{idx}/{self.dims[2]-1}")
        elif view_name == 'coronal':
            self.coronal_idx = idx
            self.coronal_slice_label.setText(f"{idx}/{self.dims[1]-1}")
        elif view_name == 'sagittal':
            self.sagittal_idx = idx
            self.sagittal_slice_label.setText(f"{idx}/{self.dims[0]-1}")
        elif view_name == 'fourth':
            self.fourth_idx = idx
            self.fourth_slice_label.setText(f"{idx}/{self.fourth_slider.maximum()}")
        
        self.update_all_views()
    
    def update_fourth_mode(self):
        """Update fourth view mode"""
        if self.volume is not None:
            mode = self.fourth_mode.currentText()
            
            # Enable/disable angle control
            self.oblique_angle.setEnabled(mode == "Oblique Plane")
            
            if mode == "Oblique Plane":
                self.update_oblique_parameters()
            else:
                self.fourth_slider.setEnabled(False)
                self.update_view('fourth', self.fourth_idx)
    
    def update_all_views(self):
        """Update all image views"""
        if self.volume is None:
            return
        
        # Axial view
        axial_data = self.volume[:, :, self.axial_idx]
        axial_norm = self.normalize(axial_data)
        self.axial_image.display_array(axial_norm, show_ref=True)
        self.axial_image.set_reference_lines(
            self.coronal_idx / max(1, self.dims[1] - 1),
            self.sagittal_idx / max(1, self.dims[0] - 1)
        )
        
        # Coronal view
        coronal_data = self.volume[:, self.coronal_idx, :].T
        coronal_data = np.rot90(coronal_data, 2)
        coronal_norm = self.normalize(coronal_data)
        self.coronal_image.display_array(coronal_norm, show_ref=True)
        self.coronal_image.set_reference_lines(
            self.sagittal_idx / max(1, self.dims[0] - 1),
            self.axial_idx / max(1, self.dims[2] - 1)
        )
        
        # Sagittal view
        sagittal_data = self.volume[self.sagittal_idx, :, :].T
        sagittal_data = np.rot90(sagittal_data, 2)
        sagittal_norm = self.normalize(sagittal_data)
        self.sagittal_image.display_array(sagittal_norm, show_ref=True)
        self.sagittal_image.set_reference_lines(
            self.coronal_idx / max(1, self.dims[1] - 1),
            self.axial_idx / max(1, self.dims[2] - 1)
        )
        
        # Fourth view
        mode = self.fourth_mode.currentText()
        if mode == "Oblique Plane":
            angle = self.oblique_angle.value()
            # Normalize position to 0-1 range
            normalized_pos = self.fourth_idx / max(1, self.fourth_slider.maximum())
            fourth_data = extract_oblique_slice(self.volume, angle, normalized_pos)
        else:  # MIP
            fourth_data = np.max(self.volume, axis=2)
        
        fourth_norm = self.normalize(fourth_data)
        self.fourth_image.display_array(fourth_norm, show_ref=False)
    
    def normalize(self, data):
        """Normalize data to 0-255 range"""
        if self.max_val <= self.min_val:
            return np.zeros_like(data, dtype=np.uint8)
        
        norm = (data - self.min_val) / (self.max_val - self.min_val)
        norm = np.clip(norm, 0, 1)
        return (norm * 255).astype(np.uint8)
    
    def toggle_roi_mode(self, checked):
        """Toggle ROI drawing mode for all views"""
        self.axial_image.set_roi_mode(checked)
        self.coronal_image.set_roi_mode(checked)
        self.sagittal_image.set_roi_mode(checked)
        self.fourth_image.set_roi_mode(checked)
        
        if checked:
            self.status_label.setText("üñä ROI Mode: Draw rectangle on any view")
        else:
            self.status_label.setText("‚úÖ ROI Mode disabled")
    
    def save_roi(self):
        """Save ROI from active view"""
        if self.volume is None:
            QMessageBox.warning(self, "No Data", "Please load DICOM data first")
            return
        
        # Check which view has an ROI
        roi_arrays = []
        view_names = []
        
        for view_name in ['axial', 'coronal', 'sagittal', 'fourth']:
            image_widget = getattr(self, f"{view_name}_image")
            roi_array = image_widget.get_roi_array()
            if roi_array is not None:
                roi_arrays.append(roi_array)
                view_names.append(view_name.capitalize())
        
        if not roi_arrays:
            QMessageBox.warning(self, "No ROI", "Please draw an ROI first")
            return
        
        # Save each ROI
        save_dir = QFileDialog.getExistingDirectory(self, "Select Save Directory")
        if not save_dir:
            return
        
        try:
            for roi_array, view_name in zip(roi_arrays, view_names):
                filename = f"ROI_{view_name}_{self.axial_idx}.png"
                filepath = Path(save_dir) / filename
                cv2.imwrite(str(filepath), roi_array)
            
            QMessageBox.information(
                self, 
                "Success", 
                f"Saved {len(roi_arrays)} ROI(s) to:\n{save_dir}"
            )
            self.status_label.setText(f"‚úÖ Saved {len(roi_arrays)} ROI(s)")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save ROI:\n{str(e)}")
    
    def batch_export_slices(self):
        """Export multiple slices to PNG files"""
        if self.volume is None:
            QMessageBox.warning(self, "No Data", "Please load DICOM data first")
            return
        
        # Get max slices based on view
        max_slices = max(self.dims)
        
        dialog = BatchExportDialog(max_slices, self)
        if dialog.exec_() != QDialog.Accepted:
            return
        
        params = dialog.get_parameters()
        view = params['view']
        start = params['start']
        end = params['end']
        step = params['step']
        
        if start > end:
            QMessageBox.warning(self, "Invalid Range", "Start slice must be <= End slice")
            return
        
        # Select save directory
        save_dir = QFileDialog.getExistingDirectory(self, "Select Save Directory")
        if not save_dir:
            return
        
        try:
            self.status_label.setText(f"‚è≥ Exporting {view} slices...")
            QApplication.processEvents()
            
            count = 0
            for idx in range(start, end + 1, step):
                # Get slice data based on view
                if view == "Axial":
                    if idx >= self.dims[2]:
                        continue
                    slice_data = self.volume[:, :, idx]
                elif view == "Coronal":
                    if idx >= self.dims[1]:
                        continue
                    slice_data = self.volume[:, idx, :].T
                    slice_data = np.rot90(slice_data, 2)
                else:  # Sagittal
                    if idx >= self.dims[0]:
                        continue
                    slice_data = self.volume[idx, :, :].T
                    slice_data = np.rot90(slice_data, 2)
                
                # Normalize and save
                normalized = self.normalize(slice_data)
                filename = f"{view}_slice_{idx:04d}.png"
                filepath = Path(save_dir) / filename
                cv2.imwrite(str(filepath), normalized)
                count += 1
            
            QMessageBox.information(
                self,
                "Export Complete",
                f"Exported {count} {view} slices to:\n{save_dir}"
            )
            self.status_label.setText(f"‚úÖ Exported {count} slices")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to export slices:\n{str(e)}")
            self.status_label.setText("‚ùå Export failed")
    
    def reset_all_zoom(self):
        """Reset zoom for all views"""
        self.axial_image.reset_zoom()
        self.coronal_image.reset_zoom()
        self.sagittal_image.reset_zoom()
        self.fourth_image.reset_zoom()
        self.status_label.setText("üîç Zoom reset for all views")
    
    def run_analysis(self):
        """Run AI analysis"""
        if self.volume is None:
            QMessageBox.warning(self, "Error", "Please load DICOM data first")
            return
        
        if not TORCH_AVAILABLE:
            QMessageBox.warning(
                self, 
                "PyTorch Not Installed",
                "Please install PyTorch:\npip install torch torchvision"
            )
            return
        
        self.analyze_btn.setEnabled(False)
        self.status_label.setText("ü§ñ Running AI analysis...")
        
        self.thread = AIThread(self.volume, self.spacing, self.orientation)
        self.thread.progress.connect(lambda msg: self.status_label.setText(f"ü§ñ {msg}"))
        self.thread.finished.connect(self.analysis_done)
        self.thread.start()
    
    def analysis_done(self, result):
        """Handle analysis completion"""
        self.analyze_btn.setEnabled(True)
        
        if 'error' in result:
            QMessageBox.critical(self, "Analysis Error", result['error'])
            self.status_label.setText("‚ùå Analysis failed")
            return
        
        predictions = result['slice_predictions']
        stats = result['volume_stats']
        
        # Format results
        msg = f"""üéØ AI Analysis Complete!

üìä Model: {result['model_used']}
üíª Device: {result['device']}
üß≠ Detected Orientation: {result['orientation']}

üîç Organ Predictions:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚Ä¢ Axial View: {predictions[0]['class']} 
  Confidence: {predictions[0]['confidence']*100:.1f}%

‚Ä¢ Coronal View: {predictions[1]['class']} 
  Confidence: {predictions[1]['confidence']*100:.1f}%

‚Ä¢ Sagittal View: {predictions[2]['class']} 
  Confidence: {predictions[2]['confidence']*100:.1f}%

üìà Volume Statistics:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚Ä¢ Total Volume: {stats['Total_Volume_ml']:.1f} mL
‚Ä¢ Mean Intensity: {stats['Mean_Intensity']:.1f}
‚Ä¢ Std Intensity: {stats['Std_Intensity']:.1f}
‚Ä¢ Intensity Range: [{stats['Min_Intensity']:.1f}, {stats['Max_Intensity']:.1f}]
"""
        
        QMessageBox.information(self, "Analysis Results", msg)
        self.status_label.setText("‚úÖ AI Analysis complete!")


def main():
    app = QApplication(sys.argv)
    app.setStyle('Fusion')
    
    # Dark theme
    app.setStyleSheet("""
        QMainWindow {
            background-color: #2b2b2b;
        }
        QWidget {
            background-color: #2b2b2b;
            color: #ffffff;
        }
        QGroupBox {
            border: 2px solid #555;
            border-radius: 5px;
            margin-top: 10px;
            padding-top: 10px;
            font-weight: bold;
        }
        QGroupBox::title {
            subcontrol-origin: margin;
            left: 10px;
            padding: 0 5px;
        }
        QPushButton {
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px;
            font-size: 12px;
        }
        QPushButton:hover {
            background-color: #2980b9;
        }
        QPushButton:pressed {
            background-color: #21618c;
        }
        QPushButton:disabled {
            background-color: #555;
            color: #888;
        }
        QPushButton:checked {
            background-color: #e74c3c;
        }
        QSlider::groove:horizontal {
            border: 1px solid #555;
            height: 10px;
            background: #555;
            margin: 2px 0;
            border-radius: 5px;
        }
        QSlider::handle:horizontal {
            background: #3498db;
            border: 1px solid #2980b9;
            width: 18px;
            margin: -5px 0;
            border-radius: 9px;
        }
        QSlider::handle:horizontal:hover {
            background: #5dade2;
        }
        QComboBox, QSpinBox, QDoubleSpinBox {
            background-color: #34495e;
            border: 1px solid #555;
            border-radius: 3px;
            padding: 5px;
            color: white;
        }
        QComboBox::drop-down {
            border: none;
        }
        QComboBox::down-arrow {
            image: none;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 5px solid white;
            margin-right: 5px;
        }
    """)
    
    viewer = DicomViewerGUI()
    viewer.show()
    
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
